/*!
 * TCP/IP Socket Progam. Client.cpp
 *
 * Copyright (c) 2017 Kim Sang Yeon
 */

#include <iostream>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <cstdlib>
#include <unistd.h>
#include <netdb.h>
#include <regex>
#include <opencv2/opencv.hpp>
#include <pthread.h>
using namespace std;
using namespace cv;
typedef int SOCKET;

SOCKET Connection;

typedef struct Pos {
	int x1, y1;
	int x2, y2;
}Pos;

Pos pos;

void draw_Rectangle() {
	Mat drawing;
	drawing = Mat::zeros(500, 500, CV_8UC3);
	rectangle(drawing, Point(pos.x1, pos.y1), Point(pos.x2, pos.y2), Scalar(200, 0, 0), 2, 3);
	imshow("image", drawing);
	waitKey(30);
}

void *ClientThread(void *ptr){
	string str;
	regex rex_Pos("(.*),(.*),(.*),(.*)");
	smatch match_Pos;
	uint32_t bufferlength;
	while (true){
		recv(Connection, &bufferlength, sizeof(uint32_t), NULL);
		bufferlength = ntohl(bufferlength);
        vector<uint8_t> buffer;
		recv(Connection, &(buffer[0]), bufferlength, NULL);
		str.assign(&(buffer[0]), buffer.size());
		if (regex_search(str, match_Pos, rex_Pos)) {
			for (int i = 1; i < match_Pos.size(); i++) {
				cout << match_Pos[i] << endl;
				if (i == 1)
					pos.x1 = stoi(match_Pos[i]);
				else if (i == 2)
					pos.y1 = stoi(match_Pos[i]);
				else if (i == 3)
					pos.x2 = stoi(match_Pos[i]);
				else
					pos.y2 = stoi(match_Pos[i]);
			}
			draw_Rectangle();
		}
		delete[] buffer;
	}
}


int main(){
    pthread_t thread1;
    sockaddr_in sock_addr; //리스닝 소켓을 바인드할 주소
	socklen_t addrlen = sizeof(sock_addr); //주소의 길이
	sock_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); //로컬호스트로 브로드 캐스트
	sock_addr.sin_port = htons(10000); //포트 번호
	sock_addr.sin_family = AF_INET; // IPv4 소켓(AF_INET6는 IPv6)

	Connection = socket(AF_INET, SOCK_STREAM, NULL); // 커넥션 소켓 설정
	if (connect(Connection, (sockaddr*)&sock_addr, sizeof(sock_addr)) != 0)
	{
		cout << "연결이 실패하였습니다."<< endl;
		return 0;
	}
	cout << "연결되었습니다!!" << endl;
	try{
        pthread_create(&thread1, NULL, &ClientThread, NULL);
	}
	catch(const bad_alloc& e){
        cout << "배드 얼로케이션"<<endl;
        return -1;
	}
	string buffer;
	while (true)
	{
		getline(cin, buffer);
		uint32_t bufferlength = htonl(buffer.size());
		send(Connection, &bufferlength, sizeof(uint32_t), NULL);
		send(Connection, buffer.c_str(), bufferlength, NULL);
		sleep(10);
	}
	pthread_join(thread1, NULL);
	system("pause");
    return 0;
}
